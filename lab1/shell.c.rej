diff a/lab1/shell.c b/lab1/shell.c	(rejected hunks)
@@ -107,187 +107,214 @@
 	}else{
 		while (*charPtr != 0x20 && *charPtr != '\0'){
 			charPtr++;
 		}
 		return charPtr;
 		/* skip to find the first char and return the fisrt ' ' pointer */
 	}
 }
 //  // TODO Step 2: skip over instances of the char skip
 //  //    return input value of charPtr if *char is null char
 
 //+
 // Function:	splitCommandLine
 //
 // Purpose:	This splits a string into an array of strings.
 //		The array is passed as an argument. The string
 //		is modified by replacing some of the space characters
 //		with null characters to terminate each of the strings.
 //
 // Parameters:
 //	commandBuffer	The string to split
 //	args		An array of char pointers
 //	maxargs		Size of array args (max number of arguments)
 //
 // Returns:	Number of arguments (< maxargs).
 //
 //-
 
 int splitCommandLine(char * commandBuffer, char* args[], int maxargs){
 
 	int counter = 0;
 
 	while (*commandBuffer != '\0')
 	{
 		if(*commandBuffer == 0x20)
 		{
 			commandBuffer =	skipChar(commandBuffer, 0x20);
 			/* skip all the space to find first char*/
 		}else{
 			args[counter] = commandBuffer;
 			commandBuffer =	skipChar(commandBuffer, *commandBuffer);
 			*commandBuffer = '\0';
 			commandBuffer++;
 			counter++;
 			/* put the first char address in the args, change the last space of char into NULL and point to the next one  */
 		}
 
 	}
 	if (counter > maxargs)
 	{
 		printf("args overflow");
 		/*check whether the args is overflowed*/
 	}
 
 	return counter;
 
    // TODO Step 2 split the command into words using only
    // the functions skipChar and strchr. You may use fprintf to report
    // errors that are encountered to stderr.
 }
 
 
 ////////////////////////////// Command Handling ///////////////////////////////////
 
 // typedef for pointer to command handling functions
 
 // TODO STEP 3a write the typedef for the function handler pointer to
 // use in the structure immediately below.
 // See the description of the function prototypes at the bottom of
 // the file in the comments.
 typedef void (*cmdFuncPtr)(char * args[], int nargs);
 
 
 // cmdType type:
 // Associates a command name with a command handling function
 // TODO STEP 3b use the typedef above (Step 3a) to make a two element
 // struct. The first is a char * for the name of the command
 // the other is a function pointer for the command handling function
 struct cmdType
 {
 	char *cmdName;
 	cmdFuncPtr cmdFunction;
 	char *args;
 	int nargs;
 };
 
 // prototypes for command handling functions
 // TODO STEP 4b,6: add a function prototype
 // for each command handling function
 void callFunction(cmdFuncPtr func, char * args[], int nargs){
 	func(args,nargs);
 }
 
 // Array that provides the list commands and functions
 // must be terminated by {NULL, NULL}
 // in a real shell, this would be a hashtable.
 // TODO Step 4a: add a global array of
 // the type above that contains initializers
 // of strings and command handling funciton names
 struct cmdType commandArrayName[] = {
+	{"pwd",pwdFunc},
 	{"exit", exitFunc},
 	{NULL,NULL}
 };
 
 //+
 // Function:	doCommand
 //
 // Purpose:	This command calls a command handling funciton from
 //		the commands array based on the first argument passed
 //		in the args array.
 //
 // Parameters:
 //	args	command and parameters, an array of pointers to strings
 //	nargs	number of entries in the args array
 //
 // Returns	nothing (void)
 //-
 
 void doCommand(char * args[], int nargs){
 
 	int counterC = 0;
 	int counterA = 0;
 	// FILE *outPutFile = fopen("test1.txt","w");
 
 	while (1)
 	{
 		if (commandArrayName[counterC].cmdName == NULL){
 			break;
 			/*hit NULL in commandArrayName*/
 	 	}
 		if (counterA == nargs)
 		{
 			printf("command is not recongnized!\n");
 			break;
 			/*hit the end of array, print error*/
 		}
 		if (strcmp(commandArrayName[counterC].cmdName,args[counterA]) == 0){
 			printf("performing %s\n",commandArrayName[counterC].cmdName);
 			callFunction(commandArrayName[counterC].cmdFunction,
 						commandArrayName[counterC].args,
 						commandArrayName[counterC].nargs);
 			counterC = 0;
 			counterA++;
 			/* exicute the function and move on */
 		}else{
 			counterC++;
 			/* move to the next command */
 		}
 	}
 	// fprintf(outPutFile,"%s\n","Test");
 	// fclose(outPutFile);
 	// /*generating test files*/
 
    // TODO Step 5 this function is small
    //  this is the command search loop
 }
 
 //////////////////////////////////////////////////
 //            command Handling Functions        //
 //////////////////////////////////////////////////
 // all command handling functions have the same
 // parameter types and return values.
 //////////////////////////////////////////////////
 
 //+
 // Function:	all handling functions
 //
 // Purpose:	this command performs the funcdtion
 //		associated with the commands.
 //		The name of the comomand is in first argument.
 //	 	Since it is called by doCommand, it is known
 //		that arg is at least one element long
 //
 // Parameters:
 //	args	command and parameters, an array of pointers to strings
 //	nargs	number of entries in the args array
 //
 // Returns	nothing (void)
 //-
 
 // TODO step 4b put command handling function for exit here
 void exitFunc(char * args[], int nargs){
 	exit(0);
 }
 
 
 // TODO step 6 put rest of command handling functions here
+void pwdFunc(char *arg[], int nargs){
+	char *cwd = getcwd(NULL, 0);
+	printf("%s\n",cwd);
+	free(cwd);
+}
+
+void cdFunc(char * args[], int nargs){
+	if (nargs == 1)
+	{
+		/*with only one performed*/
+	}else if (nargs == 0)
+	{
+		struct passwd *pw = getpwuid(getuid());
+		/*with no argument == home dir*/
+	}else
+	{
+		/* with mul arguments */
+	}
+	
+
+}
+
+void lsFunc(char * args[], int nargs){
+
+}
+
